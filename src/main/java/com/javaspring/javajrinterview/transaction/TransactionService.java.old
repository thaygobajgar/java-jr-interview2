package com.javaspring.javajrinterview.transaction;

import java.util.Optional;
import java.util.UUID;

import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.javaspring.javajrinterview.client.ClientEntity;
import com.javaspring.javajrinterview.client.ClientRepository;
import com.javaspring.javajrinterview.company.CompanyEntity;
import com.javaspring.javajrinterview.company.CompanyRepository;
import com.javaspring.javajrinterview.tax.TaxEntity;
import com.javaspring.javajrinterview.tax.TaxRepository;
import com.javaspring.javajrinterview.tax.TaxService;
import com.javaspring.javajrinterview.transaction.dtos.TransactionDTO;
import com.javaspring.javajrinterview.transaction.dtos.TransactionWithdrawDTO;

@Service
public class TransactionService {
    @Autowired
    private TransactionRepository transactionRepository;

    @Autowired
    private CompanyRepository companyRepository;

    @Autowired
    private ClientRepository clientRepository;

    @Autowired TaxService taxService;

    @Autowired
    private ModelMapper modelMapper;

    public Optional<TransactionEntity> findById(UUID id) {
        return transactionRepository.findById(id);
    }
    
    public TransactionDTO createTransaction(TransactionDTO transactionDTO) {
        CompanyEntity company = companyRepository.findById(transactionDTO.getCompanyId())
                .orElseThrow(() -> new RuntimeException("Empresa não encontrada."));
        ClientEntity client = clientRepository.findById(transactionDTO.getClientId())
                .orElseThrow(() -> new RuntimeException("Cliente não encontrado."));

        TransactionEntity transaction = modelMapper.map(transactionDTO, TransactionEntity.class);
        transaction.setCompany(company);
        transaction.setClient(client);

        if ("withdraw".equals(transaction.getType())) {
            double totalDeposits = calculateTotalAmountByType(client.getId(), "deposit");
            double totalWithdrawals = calculateTotalAmountByType(client.getId(), "withdraw");
            double currentBalance = totalDeposits - totalWithdrawals;
        
            if (transaction.getValue() > currentBalance) {
                throw new RuntimeException("Saldo insuficiente.");
            }
            // Calcula o valor da taxa de saque
            double taxAmount = transaction.getValue() * 0.02; // 2% do valor do saque
            
            
            // Ajusta o valor da transação para refletir a subtração da taxa
            transaction.setValue(transaction.getValue() - taxAmount);
        
            // Salva a transação ajustada
            TransactionEntity savedTransaction = transactionRepository.save(transaction);
        
            // Delega a criação e salvamento da TaxEntity ao TaxService
            taxService.createTax(savedTransaction, 0.02); // Passando a transação já salva e o percentual da taxa
        
            // Retorna o DTO da transação ajustado
            return modelMapper.map(savedTransaction, TransactionWithdrawDTO.class);
        }

        // Salva a transação e retorna o DTO atualizado
        TransactionEntity savedTransaction = transactionRepository.save(transaction);
        return modelMapper.map(savedTransaction, TransactionDTO.class);
    }

    // Método auxiliar para calcular o total de depósitos ou saques
    private double calculateTotalAmountByType(UUID clientId, String type) {
        return transactionRepository.findAllByClientIdAndType(clientId, type).stream()
                                    .mapToDouble(TransactionEntity::getValue)
                                    .sum();
    }

}